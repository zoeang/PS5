CISampler<-function(data,o,a){
#data= population data
# n=sample size, o=observation size, a=alpha
#-----------------------------------------------------------
trial1<-sample(data, o)
mu<- mean(trial1)
stdev<-sd(trial1)
error<- qnorm(1-a)*sigma/sqrt(o)
lbound<-mu-error
ubound<-mu+error
return(c(lbound, ubound))
}
CISampler(empvec, o=10, a=.01)
lapply(1:10, CISampler, o=10, a=.01)
lapply(1:10, CISampler, data=emptyVec, o=10, a=.01)
CISampler<-function(x, data,o,a){
#data= population data
# n=sample size, o=observation size, a=alpha
#-----------------------------------------------------------
trial1<-sample(data, o)
mu<- mean(trial1)
stdev<-sd(trial1)
error<- qnorm(1-a)*sigma/sqrt(o)
lbound<-mu-error
ubound<-mu+error
return(c(lbound, ubound))
}
CISampler(empvec, o=10, a=.01)
lapply(1:10, CISampler, data=emptyVec, o=10, a=.01)
CISampler<-function(x, data,o,a){
#data= population data
# n=sample size, o=observation size, a=alpha
#-----------------------------------------------------------
trial1<-sample(data, o)
mu<- mean(trial1)
stdev<-sd(trial1)
error<- qnorm(1-a)*sigma/sqrt(o)
lbound<-mu-error
ubound<-mu+error
return(c(lbound, ubound))
}
CISampler(empvec, o=10, a=.01)
lapply(1:10, CISampler, data=empVec, o=10, a=.01)
lapply(1:10, CISampler, data=empvec, o=10, a=.01)
sapply(1:10, CISampler, data=empvec, o=10, a=.01)
Confints<-sapply(1:numSamples, CISampler, data=dataToSample, o=sampleSize, a=.alphaLevel)
CISampler2<-function(numSamples, dataToSample, sampleSize, alphaLevel){
Confints<-sapply(1:numSamples, CISampler, data=dataToSample, o=sampleSize, a=.alphaLevel)
trueMu<-mean(dataToSample)
proportionMu<-rep(NA,numSamples)
if (trueMu>=Confints[1,i] & trueMu<=Confints[2,i]){
proportionMu[i]<-T
} else{
proportionMu[i]<-F
}
list(Confints, proportionMu)
}
CISampler2(100, empvec, 3,.03)
CISampler2<-function(numSamples, dataToSample, sampleSize, alphaLevel){
Confints<-sapply(1:numSamples, CISampler, data=dataToSample, o=sampleSize, a=alphaLevel)
trueMu<-mean(dataToSample)
proportionMu<-rep(NA,numSamples)
if (trueMu>=Confints[1,i] & trueMu<=Confints[2,i]){
proportionMu[i]<-T
} else{
proportionMu[i]<-F
}
list(Confints, proportionMu)
}
CISampler2(100, empvec, 3,.03)
CISampler2<-function(numSamples, dataToSample, sampleSize, alphaLevel){
Confints<-sapply(1:numSamples, CISampler, data=dataToSample, o=sampleSize, a=alphaLevel)
trueMu<-mean(dataToSample)
proportionMu<-rep(NA,numSamples)
for (i in 1:numSamples){
if (trueMu>=Confints[1,i] & trueMu<=Confints[2,i]){
proportionMu[i]<-T
} else{
proportionMu[i]<-F
}
}
list(Confints, proportionMu)
}
CISampler2(100, empvec, 3,.03)
CISampler2<-function(numSamples, dataToSample, sampleSize, alphaLevel){
Confints<-sapply(1:numSamples, CISampler, data=dataToSample, o=sampleSize, a=alphaLevel)
trueMu<-mean(dataToSample)
proportionMu<-rep(NA,numSamples)
for (i in 1:numSamples){
if (trueMu>=Confints[1,i] & trueMu<=Confints[2,i]){
proportionMu[i]<-T
} else{
proportionMu[i]<-F
}
}
list(Confints, sum(proportionMu)/numSamples)
}
CISampler2(100, empvec, 3,.03)
CISampler2<-function(numSamples, dataToSample, sampleSize, alphaLevel){
Confints<-sapply(1:numSamples, CISampler, data=dataToSample, o=sampleSize, a=alphaLevel)
trueMu<-mean(dataToSample)
proportionMu<-rep(NA,numSamples)
for (i in 1:numSamples){
if (trueMu>=Confints[1,i] & trueMu<=Confints[2,i]){
proportionMu[i]<-T
} else{
proportionMu[i]<-F
}
}
list(Confints, sum(proportionMu)/numSamples)
}
CISampler2(100, empvec, 3,.01)
Anscombe$education
CISampler2(100, Anscombe$education, 3,.01) #Test on data
mean(Anscombe$education)
CISampler2(100, Anscombe$education, 3,.01) #Test on data
CISampler2(100, Anscombe$education, 10,.01) #Test on data
CISampler2(50, Anscombe$education, 10,.01) #Test on data
CISampler2(50, Anscombe$education, 10,.01) #Test on data
CISampler<-function(x, data,o,a){ #the x argument allows this function to be used
#with apply functions.
#data= population data, n=sample size, o=observation size, a=alpha
trial1<-sample(data, o)
mu<- mean(trial1)
stdev<-sd(trial1)
error<- qnorm(1-a)*sigma/sqrt(o)
lbound<-mu-error
ubound<-mu+error
return(c(lbound, ubound))
}
CISampler2<-function(numSamples, dataToSample, sampleSize, alphaLevel){
Confints<-sapply(1:numSamples, CISampler, data=dataToSample,
o=sampleSize, a=alphaLevel)
trueMu<-mean(dataToSample) #Population mean
proportionMu<-rep(NA,numSamples)
for (i in 1:numSamples){#test is the pop. mean is in the CI.
if (trueMu>=Confints[1,i] & trueMu<=Confints[2,i]){
proportionMu[i]<-T
} else{
proportionMu[i]<-F
}
}
list(Confints, sum(proportionMu)/numSamples) #The output is a matrix of CIs and
#proportion of CIs that capture the pop. mean(coverage).
}
CISampler2(50, Anscombe$education, 10,.01) #Test on data
ConfidenceInterval1<- function(x, mu,n=100,standDev,alphaLevel,observationsPerSample){
samp1<-rnorm(o,mu,standDev)
error<- qnorm(1-a)*sigma/sqrt(o)
lbound<-mean(samp1)-error
ubound<-mean(samp1)+error
return(c(lbound, ubound))
}
ConfidenceInterval1<- function(x,mu,n=100,standDev,alphaLevel,observationsPerSample){
samp1<-rnorm(observationsPerSample,mu,standDev)
error<- qnorm(1-a)*sigma/sqrt(observationsPerSample)
lbound<-mean(samp1)-error
ubound<-mean(samp1)+error
return(c(lbound, ubound))
}
ConfidenceInterval1(mu=10,standDev = 1, alphaLevel = .05, observationsPerSample = 10)
ConfidenceInterval1<- function(x,mu,standDev,alphaLevel,observationsPerSample){
samp1<-rnorm(observationsPerSample,mu,standDev)
error<- qnorm(1-a)*sigma/sqrt(observationsPerSample)
lbound<-mean(samp1)-error
ubound<-mean(samp1)+error
return(c(lbound, ubound))
}
CISampler2<-function(numSamples=100,mu,standDev, alphaLevel, observationsPerSample){
Confints<-sapply(1:numSamples, ConfidenceInterval1, mu=mu, standDev=standDev,
alphaLevel=alphaLevel, observationsPerSample=observationsPerSample)
proportionMu<-rep(NA,numSamples)
for (i in 1:numSamples){
if (mu>=Confints[1,i] & mu<=Confints[2,i]){
proportionMu[i]<-T
} else{
proportionMu[i]<-F
}
}
list(Confints, sum(proportionMu)/numSamples)
}
CISampler100<-function(numSamples=100,mu,standDev, alphaLevel, observationsPerSample){
Confints<-sapply(1:numSamples, ConfidenceInterval1, mu=mu, standDev=standDev,
alphaLevel=alphaLevel, observationsPerSample=observationsPerSample)
proportionMu<-rep(NA,numSamples)
for (i in 1:numSamples){
if (mu>=Confints[1,i] & mu<=Confints[2,i]){
proportionMu[i]<-T
} else{
proportionMu[i]<-F
}
}
list(Confints, sum(proportionMu)/numSamples)
}
ConfidenceInterval1<- function(x,mu,standDev,alphaLevel,observationsPerSample){
samp1<-rnorm(observationsPerSample,mu,standDev)
error<- qnorm(1-alphalevel)*standDev/sqrt(observationsPerSample)
lbound<-mean(samp1)-error
ubound<-mean(samp1)+error
return(c(lbound, ubound))
}
ConfidenceInterval1(mu=10, standDev =1,alphaLevel=.05,observationsPerSample=10 )
ConfidenceInterval1<- function(x,mu,standDev,alphaLevel,observationsPerSample){
samp1<-rnorm(observationsPerSample,mu,standDev)
error<- qnorm(1-alphaLevel)*standDev/sqrt(observationsPerSample)
lbound<-mean(samp1)-error
ubound<-mean(samp1)+error
return(c(lbound, ubound))
}
ConfidenceInterval1(mu=10, standDev =1,alphaLevel=.05,observationsPerSample=10 )
ConfidenceInterval1(mu=10, standDev =1,alphaLevel=.05,observationsPerSample=10 )
ConfidenceInterval1(mu=10, standDev =1,alphaLevel=.05,observationsPerSample=10 )
CISampler100<-function(numSamples=100,mu,standDev, alphaLevel, observationsPerSample){
Confints<-sapply(1:numSamples, ConfidenceInterval1, mu=mu, standDev=standDev,
alphaLevel=alphaLevel, observationsPerSample=observationsPerSample)
proportionMu<-rep(NA,numSamples)
for (i in 1:numSamples){
if (mu>=Confints[1,i] & mu<=Confints[2,i]){
proportionMu[i]<-T
} else{
proportionMu[i]<-F
}
}
list(Confints, sum(proportionMu)/numSamples)
}
CISampler100(mu=10,standDev=1, alphaLevel=.05, observationsPerSample)
ConfidenceInterval1<- function(x,mu,standDev,alphaLevel,observationsPerSample){
#the x argument allows this function to be used
samp1<-rnorm(observationsPerSample,mu,standDev)
error<- qnorm(1-alphaLevel)*standDev/sqrt(observationsPerSample)
lbound<-mean(samp1)-error
ubound<-mean(samp1)+error
return(c(lbound, ubound))
}
CISampler100<-function(numSamples=100,mu,standDev, alphaLevel, observationsPerSample){
Confints<-sapply(1:numSamples, ConfidenceInterval1, mu=mu, standDev=standDev,
alphaLevel=alphaLevel, observationsPerSample=observationsPerSample)
proportionMu<-rep(NA,numSamples)
for (i in 1:numSamples){
if (mu>=Confints[1,i] & mu<=Confints[2,i]){
proportionMu[i]<-T
} else{
proportionMu[i]<-F
}
}
list(Confints, sum(proportionMu)/numSamples)
}
CISampler100(mu=10,standDev=1, alphaLevel=.025, observationsPerSample=10)#Test
head(CISampler100(mu=10,standDev=1, alphaLevel=.025, observationsPerSample=10),5)#Test
CISampler100(mu=10,standDev=1, alphaLevel=.025, observationsPerSample=10)[1]#Test
head(CISampler100(mu=10,standDev=1, alphaLevel=.025, observationsPerSample=10)[1],5)#Test
CISampler100(numSamples=5,mu=10,standDev=1, alphaLevel=.025, observationsPerSample=10)
CISampler100(numSamples=5,mu=10,standDev=1, alphaLevel=.025, observationsPerSample=10)
CISampler100(numSamples=5,mu=10,standDev=1, alphaLevel=.025, observationsPerSample=10)
CISampler100(numSamples=5,mu=10,standDev=1, alphaLevel=.025, observationsPerSample=10)
CISampler100<-function(numSamples=100,mu,standDev, alphaLevel, observationsPerSample){
#sapply replicates ConfidenceInterval1 as many times indicated by numSamples
Confints<-sapply(1:numSamples, ConfidenceInterval1, mu=mu, standDev=standDev,
alphaLevel=alphaLevel, observationsPerSample=observationsPerSample)
#Find the coverage
proportionMu<-rep(NA,numSamples)
for (i in 1:numSamples){
if (mu>=Confints[1,i] & mu<=Confints[2,i]){
proportionMu[i]<-T
} else{
proportionMu[i]<-F
}
}
row.names(Confints)<c(Lower Bound, Upper Bound)
#Return a list of 1)a matrix of CIs and 2)the coverage
list(Confints, sum(proportionMu)/numSamples)
}
CISampler100(mu=10,standDev=1, alphaLevel=.025, observationsPerSample=10)
CISampler100<-function(numSamples=100,mu,standDev, alphaLevel, observationsPerSample){
#sapply replicates ConfidenceInterval1 as many times indicated by numSamples
Confints<-sapply(1:numSamples, ConfidenceInterval1, mu=mu, standDev=standDev,
alphaLevel=alphaLevel, observationsPerSample=observationsPerSample)
#Find the coverage
proportionMu<-rep(NA,numSamples)
for (i in 1:numSamples){
if (mu>=Confints[1,i] & mu<=Confints[2,i]){
proportionMu[i]<-T
} else{
proportionMu[i]<-F
}
}
row.names(Confints)<c("Lower Bound", "Upper Bound")
#Return a list of 1)a matrix of CIs and 2)the coverage
list(Confints, sum(proportionMu)/numSamples)
}
CISampler100(mu=10,standDev=1, alphaLevel=.025, observationsPerSample=10)
CISampler100<-function(numSamples=100,mu,standDev, alphaLevel, observationsPerSample){
#sapply replicates ConfidenceInterval1 as many times indicated by numSamples
Confints<-sapply(1:numSamples, ConfidenceInterval1, mu=mu, standDev=standDev,
alphaLevel=alphaLevel, observationsPerSample=observationsPerSample)
rownames(Confints)<-c("Lower Bound", "Upper Bound")
#Find the coverage
proportionMu<-rep(NA,numSamples)
for (i in 1:numSamples){
if (mu>=Confints[1,i] & mu<=Confints[2,i]){
proportionMu[i]<-T
} else{
proportionMu[i]<-F
}
}
row.names(Confints)<c("Lower Bound", "Upper Bound")
#Return a list of 1)a matrix of CIs and 2)the coverage
list(Confints, sum(proportionMu)/numSamples)
}
CISampler100(mu=10,standDev=1, alphaLevel=.025, observationsPerSample=10)
CISampler100<-function(numSamples=100,mu,standDev, alphaLevel, observationsPerSample){
#sapply replicates ConfidenceInterval1 as many times indicated by numSamples
Confints<-sapply(1:numSamples, ConfidenceInterval1, mu=mu, standDev=standDev,
alphaLevel=alphaLevel, observationsPerSample=observationsPerSample)
rownames(Confints)<-c("Lower Bound", "Upper Bound")
#Find the coverage
proportionMu<-rep(NA,numSamples)
for (i in 1:numSamples){
if (mu>=Confints[1,i] & mu<=Confints[2,i]){
proportionMu[i]<-T
} else{
proportionMu[i]<-F
}
}
row.names(Confints)<c("Lower Bound", "Upper Bound")
#Return a list of 1)a matrix of CIs and 2)the coverage
output<-list(Confints, sum(proportionMu)/numSamples)
names(output)<-c("Confidence Intervals", "Coverage")
}
CISampler100(mu=10,standDev=1, alphaLevel=.025, observationsPerSample=10)
CISampler100<-function(numSamples=100,mu,standDev, alphaLevel, observationsPerSample){
#sapply replicates ConfidenceInterval1 as many times indicated by numSamples
Confints<-sapply(1:numSamples, ConfidenceInterval1, mu=mu, standDev=standDev,
alphaLevel=alphaLevel, observationsPerSample=observationsPerSample)
rownames(Confints)<-c("Lower Bound", "Upper Bound")
#Find the coverage
proportionMu<-rep(NA,numSamples)
for (i in 1:numSamples){
if (mu>=Confints[1,i] & mu<=Confints[2,i]){
proportionMu[i]<-T
} else{
proportionMu[i]<-F
}
}
row.names(Confints)<c("Lower Bound", "Upper Bound")
#Return a list of 1)a matrix of CIs and 2)the coverage
output<-list(Confints, sum(proportionMu)/numSamples)
names(output)<-c("ConfidenceIntervals", "Coverage")
return(c(head(output$ConfidenceIntervals,5),ouput$Coverage))
}
CISampler100(mu=10,standDev=1, alphaLevel=.025, observationsPerSample=10)
CISampler100<-function(numSamples=100,mu,standDev, alphaLevel, observationsPerSample){
#sapply replicates ConfidenceInterval1 as many times indicated by numSamples
Confints<-sapply(1:numSamples, ConfidenceInterval1, mu=mu, standDev=standDev,
alphaLevel=alphaLevel, observationsPerSample=observationsPerSample)
rownames(Confints)<-c("Lower Bound", "Upper Bound")
#Find the coverage
proportionMu<-rep(NA,numSamples)
for (i in 1:numSamples){
if (mu>=Confints[1,i] & mu<=Confints[2,i]){
proportionMu[i]<-T
} else{
proportionMu[i]<-F
}
}
row.names(Confints)<c("Lower Bound", "Upper Bound")
#Return a list of 1)a matrix of CIs and 2)the coverage
output<-list(Confints, sum(proportionMu)/numSamples)
names(output)<-c("ConfidenceIntervals", "Coverage")
return(c(head(output$ConfidenceIntervals,5),output$Coverage))
}
CISampler100(mu=10,standDev=1, alphaLevel=.025, observationsPerSample=10)
CISampler100<-function(numSamples=100,mu,standDev, alphaLevel, observationsPerSample){
#sapply replicates ConfidenceInterval1 as many times indicated by numSamples
Confints<-sapply(1:numSamples, ConfidenceInterval1, mu=mu, standDev=standDev,
alphaLevel=alphaLevel, observationsPerSample=observationsPerSample)
rownames(Confints)<-c("Lower Bound", "Upper Bound")
#Find the coverage
proportionMu<-rep(NA,numSamples)
for (i in 1:numSamples){
if (mu>=Confints[1,i] & mu<=Confints[2,i]){
proportionMu[i]<-T
} else{
proportionMu[i]<-F
}
}
row.names(Confints)<c("Lower Bound", "Upper Bound")
#Return a list of 1)a matrix of CIs and 2)the coverage
output<-list(Confints, sum(proportionMu)/numSamples)
names(output)<-c("ConfidenceIntervals", "Coverage")
return(output)
}
CISampler100(mu=10,standDev=1, alphaLevel=.025, observationsPerSample=10)
multivarCI<-function(X, beta, quant, sigma){
ansubound<-beta+quant*sqrt(annVar)
anslbound<-beta-quant*sqrt(ansVar)
}
sapply(X, multivarCI,beta=ansBeta, quantile=quant, sigma=ansVar)
sapply(X=1:3, multivarCI,beta=ansBeta, quantile=quant, sigma=ansVar)
library(car)
regAns<-lm(education~income+young+urban, data=Anscombe)
ansBeta<-regAns$coefficients[2:4] #These are the beta hats
ansVar<-diag(vcov(regAns))[2:4] #These are sigma v_jj
quant<-qt(.87,46)
multivarCI<-function(X, beta, quant, sigma){
ansubound<-beta+quant*sqrt(annVar)
anslbound<-beta-quant*sqrt(ansVar)
}
sapply(X=1:3, multivarCI,beta=ansBeta, quant=quant, sigma=ansVar)
multivarCI<-function(X, beta, quant, sigma){
ansubound<-beta+quant*sqrt(ansVar)
anslbound<-beta-quant*sqrt(ansVar)
}
sapply(X=1:3, multivarCI,beta=ansBeta, quant=quant, sigma=ansVar)
multivarCI(beta=ansBeta, quant=quant, sigma=ansVar)
multivarCI<-function(X, beta, quant, sigma){
ansubound<-beta+quant*sqrt(ansVar)
anslbound<-beta-quant*sqrt(ansVar)
return(c(anslbound, ansubound))
}
multivarCI(beta=ansBeta, quant=quant, sigma=ansVar)
sapply(X=1:3, multivarCI,beta=ansBeta, quant=quant, sigma=ansVar)
sapply(X=, multivarCI,beta=ansBeta, quant=quant, sigma=ansVar)
multivarCI(beta=ansBeta, quant=quant, sigma=ansVar)
multivarCI<-function(X, beta, quant, sigma){
ansubound<-beta+quant*sqrt(ansVar)
anslbound<-beta-quant*sqrt(ansVar)
return(cbind(anslbound, ansubound))
}
multivarCI(beta=ansBeta, quant=quant, sigma=ansVar)
confint(regAns,parm=c("income", "young", "urban"), level=.87)
pnorm(2.67, 3, .096)
install.packages("stargazer")
lm(tfr~contraceptors, data=Robey)
summary(lm(tfr~contraceptors, data=Robey))
stargazer::lm(tfr~contraceptors, data=Robey)
stargazer(lm(tfr~contraceptors, data=Robey))
integrateIt<- function(x, y, a, b, rule){
if(rule=="trap"){
library(zoo)
trapezoid<- function(x, y, a, b, rule){
n<-length(x)
a<-min(x)
b<-max(x)
h<- (b-a)/n
midx<-3:length(x)-1
id <- order(x)
AUC<- h/2*(y[1]+2*sum(y[midx])+y[length(y)])
return(new(class="trapezoid", x=x, y=y, result=AUC))
}
trapezoid(x,y,a,b,rule)
} else if (rule=="simpsons"){
simpsons<-function(x, y, a, b, rule){
n<-length(x)
a<-min(x)
b<-max(x)
h<- (b-a)/n
#multiple even index by 4
#multiple odd index by 2
even4<-seq(2,n-1,2)
odd2<-seq(3,n-1,2)
S<- h/3*(y[1]+4*sum(y[even4])+ 2*sum(y[odd2])+ y[length(y)])
return(new(class="simpson", x=x, y=y, result=S))
}
simpsons(x, y, a, b, rule)
} else {
print("'rule' does not properly indicate the class of the integration method.")
}
}
library(devtools)
library(roxygen2)
setwd("C:/Users/zoeja/OneDrive/Documents/Spring2018/R/PS5") #This will need to be changed to match your directory
current.code <- as.package("integrateIt")
load_all(current.code)
document(current.code)
test(current.code)
x<-seq(1,9,1)
y<-c(2,3,7,3,800,8,9,4,1)
integrateIt(x,y,a,b, "simpsons")
print(x)
print.simpson <- function(){
}
n<-length(x)
a<-min(x)
b<-max(x)
h<- (b-a)/n
midx<-3:length(x)-1
id <- order(x)
AUC<- h/2*(y[1]+2*sum(y[midx])+y[length(y)])
return(new(class="trapezoid", x=x, y=y, result=AUC))
new("trapezoid", x=x,y=y, result=AUC)
return(new("trapezoid", x=x,y=y, result=AUC)
}
trapezoid(x,y,a,b,rule)
} else if (rule=="simpsons"){
simpsons<-function(x, y, a, b, rule){
n<-length(x)
a<-min(x)
b<-max(x)
h<- (b-a)/n
#multiple even index by 4
#multiple odd index by 2
even4<-seq(2,n-1,2)
odd2<-seq(3,n-1,2)
S<- h/3*(y[1]+4*sum(y[even4])+ 2*sum(y[odd2])+ y[length(y)])
return(new("trapezoid", x=x,y=y, result=S)
}
simpsons(x, y, a, b, rule)
} else {
print("'rule' does not properly indicate the class of the integration method.")
}
}
