}
sapply(X, multivarCI,beta=ansBeta, quantile=quant, sigma=ansVar)
sapply(X=1:3, multivarCI,beta=ansBeta, quantile=quant, sigma=ansVar)
library(car)
regAns<-lm(education~income+young+urban, data=Anscombe)
ansBeta<-regAns$coefficients[2:4] #These are the beta hats
ansVar<-diag(vcov(regAns))[2:4] #These are sigma v_jj
quant<-qt(.87,46)
multivarCI<-function(X, beta, quant, sigma){
ansubound<-beta+quant*sqrt(annVar)
anslbound<-beta-quant*sqrt(ansVar)
}
sapply(X=1:3, multivarCI,beta=ansBeta, quant=quant, sigma=ansVar)
multivarCI<-function(X, beta, quant, sigma){
ansubound<-beta+quant*sqrt(ansVar)
anslbound<-beta-quant*sqrt(ansVar)
}
sapply(X=1:3, multivarCI,beta=ansBeta, quant=quant, sigma=ansVar)
multivarCI(beta=ansBeta, quant=quant, sigma=ansVar)
multivarCI<-function(X, beta, quant, sigma){
ansubound<-beta+quant*sqrt(ansVar)
anslbound<-beta-quant*sqrt(ansVar)
return(c(anslbound, ansubound))
}
multivarCI(beta=ansBeta, quant=quant, sigma=ansVar)
sapply(X=1:3, multivarCI,beta=ansBeta, quant=quant, sigma=ansVar)
sapply(X=, multivarCI,beta=ansBeta, quant=quant, sigma=ansVar)
multivarCI(beta=ansBeta, quant=quant, sigma=ansVar)
multivarCI<-function(X, beta, quant, sigma){
ansubound<-beta+quant*sqrt(ansVar)
anslbound<-beta-quant*sqrt(ansVar)
return(cbind(anslbound, ansubound))
}
multivarCI(beta=ansBeta, quant=quant, sigma=ansVar)
confint(regAns,parm=c("income", "young", "urban"), level=.87)
pnorm(2.67, 3, .096)
install.packages("stargazer")
lm(tfr~contraceptors, data=Robey)
summary(lm(tfr~contraceptors, data=Robey))
stargazer::lm(tfr~contraceptors, data=Robey)
stargazer(lm(tfr~contraceptors, data=Robey))
library(faraway)
qt(95,7)
qt(.95,7)
qt(.975,7)
3.06-2.364624*.5125
1.84813*.5125
0.9471666/(sqrt(8))
0.334874-3.06
3.06+2.365*.5125
4.272063*.5125
2.189432/(sqrt(8))
0.7740811-3.06
qt(.95,24)
qt(.1,24)
qt(.9, 24)
qnorm(.9)
qnrom(.95)
qnorm(.95)
1.65/5
-.36+2.33+1.23-.24+.96+.77
4.69/6
(2.33-.36+1.23-.27+.96+.77)/6
read.csv("https://wustl.blackboard.com/bbcswebdav/pid-3333877-dt-content-rid-15690530_1/courses/SP2018.L32.Pol_Sci.581.01/data-hwk.txt.txt")
install.packages("foreign")
library(foreign)
read.table.url("https://wustl.blackboard.com/bbcswebdav/pid-3333877-dt-content-rid-15690530_1/courses/SP2018.L32.Pol_Sci.581.01/data-hwk.txt.txt")
read.table("https://wustl.blackboard.com/bbcswebdav/pid-3333877-dt-content-rid-15690530_1/courses/SP2018.L32.Pol_Sci.581.01/data-hwk.txt.txt")
read.table("https:\\wustl.blackboard.com\bbcswebdav\pid-3333877-dt-content-rid-15690530_1\courses\SP2018.L32.Pol_Sci.581.01\data-hwk.txt.txt")
read.table("data-hwk.txt.txt")
getwd()
read.table("C:\Users\zoeja\OneDrive\Documents\Spring2018\QPM 1\Week 7\data-hwk.txt.txt")
read.table("~\Spring2018\QPM 1\Week 7\data-hwk.txt.txt")
read.table("~Spring2018\QPM 1\Week 7\data-hwk.txt.txt")
read.table("C:/Users/zoeja/OneDrive/Documents/Spring2018/QPM 1/Week 7/data-hwk.txt.txt")
library(devtools)
library(roxygen2)
setwd("C:\Users\zoeja\OneDrive\Documents\Spring2018\R\PS5") #This will need to be changed to match your directory
current.code <- as.package("integrateIt")
setwd("C:\Users\zoeja\OneDrive\Documents\Spring2018\R\PS5") #This will need to be changed to match your directory
setwd("C:/Users/zoeja/OneDrive/Documents/Spring2018/R/PS5") #This will need to be changed to match your directory
current.code <- as.package("integrateIt")
create(integrateIt)
current.code <- as.package("integrateIt")
load_all(current.code)
document(current.code)
setwd("C:/Users/zoeja/OneDrive/Documents/Spring2018/R") #This will need to be changed to match your directory
library(devtools)
library(roxygen2)
setwd("C:/Users/zoeja/OneDrive/Documents/Spring2018/R/PS5") #This will need to be changed to match your directory
current.code <- as.package("integrateIt")
setwd("C:/Users/zoeja/OneDrive/Documents/Spring2018/R/PS5") #This will need to be changed to match your directory
current.code <- as.package("integrateIt")
setwd("C:/Users/zoeja/OneDrive/Documents/Spring2018/R/PS5") #This will need to be changed to match your directory
getwd()
current.code <- as.package("integrateIt")
load_all(current.code)
setwd("C:/Users/zoeja/OneDrive/Documents/Spring2018/R") #This will need to be changed to match your directory
current.code <- as.package("integrateIt")
current.code <- as.package("integrateIt")
current.code <- as.package("integrateIt")
load_all(current.code)
load_all(current.code)
document(current.code)
x<-seq(1,10,1)
y<-c(2,3,7,3,2,6,8,9,4,1)
integrateIt(x,y,a,b, "trap")
x<-seq(1,9,1)
y<-c(2,3,7,3,800,8,9,4,1)
integrateIt(x,y,a,b, "trap")
integrateIt(x,y,a,b, "simpsons")
print.simpsons(x)
setMethod("print", "trapezoid",
function(x){ #the argument of functio MUST be the same as the argument in the generic
#if creating a method for an existing generic/function, use the help file to
#find the argument for the function of the new method
return(x@trapezoid)
})
setMethod("print", "simpsons",
function(x){ #the argument of functio MUST be the same as the argument in the generic
#if creating a method for an existing generic/function, use the help file to
#find the argument for the function of the new method
return(x@simpsons)
})
setClass(Class="simpsons",
representation = representation(
x="numeric", #set the class of the slot
y="numeric",
result="numeric"
),
prototype= prototype(
x=c(), #leave the default data empty
y=c(),
result=c()
)
)
setValidity("trapezoid", function(x, y, a, b, rule="simpsons"){
test1<-length(x)==length(y)
test2<-x>=a
test3<-x<=b
test4<-rule=="simpsons"
if(test1 ==F){return("x and y are not of equal length")}
if(test2==F){return("a must be greater than or equal to x")}
if(test3==F){return("b must be less than or equal to x")}
if(test4==F){return('rule must be "simpsons"')}
}
)
setMethod("initialize", "simpsons", function(.Object, ...){
value=callNexMethod()
validObject(value)
return(value)
})
setMethod("integrateIt", "simpsons",
function(object){ #the argument of functio MUST be the same as the argument in the generic
#if creating a method for an existing generic/function, use the help file to
#find the argument for the function of the new method
return(object@simpsons)
})
setMethod("print", "trapezoid",
function(x){ #the argument of functio MUST be the same as the argument in the generic
#if creating a method for an existing generic/function, use the help file to
#find the argument for the function of the new method
return(x@trapezoid)
})
data<-read.table("C:/Users/zoeja/OneDrive/Documents/Spring2018/QPM 1/Week 7/data-hwk.txt.txt")
data
nrow(data)
integrateIt(x,y,a,b, "simpsons")
print.simpsons(x)
integrateIt(x,y,a,b, "simpsons")
integrateIt<- function(x, y, a, b, rule){
if(rule=="trap"){
library(zoo)
trapezoid<- function(x, y, a, b, rule){
n<-length(x)
a<-min(x)
b<-max(x)
h<- (b-a)/n
midx<-3:length(x)-1
id <- order(x)
AUC<- h/2*(y[1]+2*sum(y[midx])+y[length(y)])
return(new(class="trapezoid", x=x, y=y, result=AUC))
}
trapezoid(x,y,a,b,rule)
} else if (rule=="simpsons"){
simpsons<-function(x, y, a, b, rule){
n<-length(x)
a<-min(x)
b<-max(x)
h<- (b-a)/n
#multiple even index by 4
#multiple odd index by 2
even4<-seq(2,n-1,2)
odd2<-seq(3,n-1,2)
S<- h/3*(y[1]+4*sum(y[even4])+ 2*sum(y[odd2])+ y[length(y)])
return(new(class="simpson", x=x, y=y, result=S))
}
simpsons(x, y, a, b, rule)
} else {
print("'rule' does not properly indicate the class of the integration method.")
}
}
integrateIt(x,y,a,b, "simpsons")
setClass(Class="simpsons",
representation = representation(
x="numeric", #set the class of the slot
y="numeric",
result="numeric"
),
prototype= prototype(
x=c(), #leave the default data empty
y=c(),
result=c()
)
)
setValidity("simpsons", function(x, y, a, b, rule="simpsons"){
test1<-length(x)==length(y)
test2<-x>=a
test3<-x<=b
test4<-rule=="simpsons"
if(test1 ==F){return("x and y are not of equal length")}
if(test2==F){return("a must be greater than or equal to x")}
if(test3==F){return("b must be less than or equal to x")}
if(test4==F){return('rule must be "simpsons"')}
}
)
setMethod("initialize", "simpsons", function(.Object, ...){
value=callNexMethod()
validObject(value)
return(value)
})
setMethod("integrateIt", "simpsons",
function(object){ #the argument of functio MUST be the same as the argument in the generic
#if creating a method for an existing generic/function, use the help file to
#find the argument for the function of the new method
return(object@simpsons)
})
setMethod("print", "simpsons",
function(x){ #the argument of functio MUST be the same as the argument in the generic
#if creating a method for an existing generic/function, use the help file to
#find the argument for the function of the new method
return(x@result)
})
setClass(Class="simpsons",
representation = representation(
x="numeric", #set the class of the slot
y="numeric",
result="numeric"
),
prototype= prototype(
x=c(), #leave the default data empty
y=c(),
result=c()
)
)
setValidity("simpsons", function(x, y, a, b, rule="simpsons"){
test1<-length(x)==length(y)
test2<-x>=a
test3<-x<=b
test4<-rule=="simpsons"
if(test1 ==F){return("x and y are not of equal length")}
if(test2==F){return("a must be greater than or equal to x")}
if(test3==F){return("b must be less than or equal to x")}
if(test4==F){return('rule must be "simpsons"')}
}
)
setClass(Class="simpsons",
representation = representation(
x="numeric", #set the class of the slot
y="numeric",
result="numeric"
),
prototype= prototype(
x=c(), #leave the default data empty
y=c(),
result=c()
)
)
setValidity("simpsons", function(x, y){
test1<-length(x)==length(y)
if(test1 ==F){return("x and y are not of equal length")}
}
)
setMethod("initialize", "simpsons", function(.Object, ...){
value=callNexMethod()
validObject(value)
return(value)
})
setMethod("integrateIt", "simpsons",
function(object){ #the argument of functio MUST be the same as the argument in the generic
#if creating a method for an existing generic/function, use the help file to
#find the argument for the function of the new method
return(object@simpsons)
})
setMethod("print", "simpsons",
function(x){ #the argument of functio MUST be the same as the argument in the generic
#if creating a method for an existing generic/function, use the help file to
#find the argument for the function of the new method
return(x@result)
})
current.code <- as.package("integrateIt")
load_all(current.code)
document(current.code)
x<-seq(1,9,1)
y<-c(2,3,7,3,800,8,9,4,1)
integrateIt(x,y,a,b, "simpsons")
setClass(Class="simpsons",
representation = representation(
x="numeric", #set the class of the slot
y="numeric",
result="numeric"
),
prototype= prototype(
x=c(), #leave the default data empty
y=c(),
result=c()
)
)
setValidity("simpsons", function(x, y){
test1<-length(x)==length(y)
if(test1 ==F){return("x and y are not of equal length")}
}
)
setMethod("initialize", "simpsons", function(.Object, ...){
value=callNexMethod()
validObject(value)
return(value)
})
setMethod("integrateIt", "simpsons",
function(object){ #the argument of functio MUST be the same as the argument in the generic
#if creating a method for an existing generic/function, use the help file to
#find the argument for the function of the new method
return(object@simpsons)
})
setGeneric("integrateIt",
function(object=c('trapezoid', 'simpsons')) { #***
standardGeneric("integrateIt")
})
setMethod("initialize", "simpsons", function(.Object, ...){
value=callNexMethod()
validObject(value)
return(value)
})
setMethod("integrateIt", "simpsons",
function(object){ #the argument of functio MUST be the same as the argument in the generic
#if creating a method for an existing generic/function, use the help file to
#find the argument for the function of the new method
return(object@simpsons)
})
setMethod("print", "simpsons",
function(x){ #the argument of functio MUST be the same as the argument in the generic
#if creating a method for an existing generic/function, use the help file to
#find the argument for the function of the new method
return(print("The simpson approximation is:",x@result))
})
setValidity("simpsons", function(x, y){
test1<-length(x)==length(y)
if(test1 ==F){return("x and y are not of equal length")}
}
)
setValidity(Class = "simpsons", method="integrateIt",function(x, y){
test1<-length(x)==length(y)
if(test1 ==F){return("x and y are not of equal length")}
}
)
setValidity(Class = "simpsons", function(object){
test1<-length(object@x)==length(object@y)
if(test1 ==F){return("x and y are not of equal length")}
}
)
setValidity(Class = "trapezoid", function(object){
test1<-length(object@x)==length(object@y)
if(test1 ==F){return("x and y are not of equal length")}
}
)
setGeneric("integrateIt",
function(object=c('trapezoid', 'simpsons')) { #***
standardGeneric("integrateIt")
})
setClass(Class="trapezoid",
representation = representation(
x="numeric", #set the class of the slot
y="numeric",
result="numeric"
),
prototype= prototype(
x=c(), #leave the default data empty
y=c(),
result=c()
)
)
setValidity(Class = "trapezoid", function(object){
test1<-length(object@x)==length(object@y)
if(test1 ==F){return("x and y are not of equal length")}
}
)
setMethod("initialize", "trapezoid", function(.Object, ...){
value=callNexMethod()
validObject(value)
return(value)
})
setGeneric("integrateIt",
function(object=c('trapezoid', 'simpsons')) { #***
standardGeneric("integrateIt")
})
setMethod("integrateIt", "trapezoid",
function(object){ #the argument of functio MUST be the same as the argument in the generic
#if creating a method for an existing generic/function, use the help file to
#find the argument for the function of the new method
return(object@trapezoid)
})
setMethod("print", "trapezoid",
function(x){ #the argument of functio MUST be the same as the argument in the generic
#if creating a method for an existing generic/function, use the help file to
#find the argument for the function of the new method
return(print("The trapezoid approximation is:",x@result))
})
current.code <- as.package("integrateIt")
load_all(current.code)
document(current.code)
x<-seq(1,9,1)
y<-c(2,3,7,3,800,8,9,4,1)
integrateIt(x,y,a,b, "simpsons")
integrateIt<- function(x, y, a, b, rule){
if(rule=="trap"){
library(zoo)
trapezoid<- function(x, y, a, b, rule){
n<-length(x)
a<-min(x)
b<-max(x)
h<- (b-a)/n
midx<-3:length(x)-1
id <- order(x)
AUC<- h/2*(y[1]+2*sum(y[midx])+y[length(y)])
return(new(class="trapezoid", x=x, y=y, result=AUC))
}
trapezoid(x,y,a,b,rule)
} else if (rule=="simpsons"){
simpsons<-function(x, y, a, b, rule){
n<-length(x)
a<-min(x)
b<-max(x)
h<- (b-a)/n
#multiple even index by 4
#multiple odd index by 2
even4<-seq(2,n-1,2)
odd2<-seq(3,n-1,2)
S<- h/3*(y[1]+4*sum(y[even4])+ 2*sum(y[odd2])+ y[length(y)])
return(new(class="simpson", x=x, y=y, result=S))
}
simpsons(x, y, a, b, rule)
} else {
print("'rule' does not properly indicate the class of the integration method.")
}
}
current.code <- as.package("integrateIt")
load_all(current.code)
document(current.code)
integrateIt(x,y,a,b, "simpsons")
test(current.code)
setwd("C:/Users/zoeja/OneDrive/Documents/Spring2018/R/PS5") #This will need to be changed to match your directory
current.code <- as.package("integrateIt")
load_all(current.code)
current.code <- as.package("integrateIt")
load_all(current.code)
document(current.code)
test(current.code)
context("Vector length")
test_that("The input vectors are of equal length",{
expect_that(length(x), equal(length(y)))
})
test_check("integrateIt")
library(testthat)
library(integrateIt)
test_check("integrateIt")
context("Vector length")
test_that("The input vectors are of equal length",{
expect_that(length(x), equal(length(y)))
})
context("Vector length")
test_that("The input vectors are of equal length",{
expect_that(length(x), equals(length(y)))
})
test(current.code)
current.code <- as.package("integrateIt")
load_all(current.code)
document(current.code)
test(current.code)
current.code <- as.package("integrateIt")
load_all(current.code)
document(current.code)
test(current.code)
current.code <- as.package("integrateIt")
load_all(current.code)
document(current.code)
test(current.code)
current.code <- as.package("integrateIt")
load_all(current.code)
document(current.code)
test(current.code)
length(x)
length(y)
length(x)
test_that("The input vectors are of equal length",{
expect_that(length(x), equals(length(y)))
})
context("Vector length")
current.code <- as.package("integrateIt")
load_all(current.code)
document(current.code)
test(current.code)
print(x)
